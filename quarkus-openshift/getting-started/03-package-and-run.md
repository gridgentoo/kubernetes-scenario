На предыдущем шаге вы добавили в приложение пользовательский **CDI bean**. Теперь пришло время упаковать **package** и запустить его как автономный файл **JAR**.

### Остановить предыдущее приложение

Давайте остановим исходное приложение, чтобы мы могли упаковать **package** и повторно запустить его как исполняемый **executable JAR**. В терминале нажмите `CTRL-C`, чтобы остановить приложение.

### **Package** - упакуйте приложение **app**

Упакуйте **application**:

`mvn package`{{execute}}. Это произведет 2 **jar** файла:

* `getting-started-1.0-SNAPSHOT.jar` - содержит только **classes** и **resources** проектов, это обычный **artifact**, созданный сборкой **Maven build**

* `getting-started-1.0-SNAPSHOT-runner.jar` - будучи исполняемым **executable jar**. Имейте в виду, что это не **über-jar**, поскольку зависимости копируются в директорию`target/lib`.

Посмотрите файлы с этой командой:

`ls -l target/*.jar`{{execute}}

## Запустить исполняемый **JAR**

Вы можете запустить упакованное **packaged** приложение, кликнув: 

`java -jar target/getting-started-1.0-SNAPSHOT-runner.jar`{{execute}}

А затем протестируйте его снова, используя браузер, чтобы получить доступ к конечной точке **endpoint** `/ hello /reeting`, передавая `quarkus` в URL с помощью [this link](https://[[CLIENT_SUBDOMAIN]]-8080-[[KATACODA_HOST]].environments.katacoda.com/hello/greeting/quarkus).


Тебе следует увидеть::

```console
hello quarkus from master
```

> Запись `Class-Path` в файле `MANIFEST.MF` из _runner jar_ явно перечисляет **jar** из каталога `lib`. Поэтому, если вы хотите развернуть свое приложение где-нибудь, вам нужно скопировать _runner jar_ , а также директорию _lib_. Если вы хотите создать **Uber-jar** со всем включенниями **included**, вы можете использовать `mvn pakage -DuberJar`.

## Cleanup - уборка
Вернитесь к терминалу и снова остановите приложение, нажав `CTRL-C`.

## Поздравляем!

Вы упаковали **packaged** приложение в виде исполняемого файла **JAR** и немного больше узнали о механике упаковки **packaging**. На следующем шаге мы продолжим наше путешествие и создадим _native image_, а затем узнаем о создании собственного исполняемого файла и упаковке в **Linux container**.

